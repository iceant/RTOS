# CPU中实现调度

操作系统最重要的功能就是任务管理，而任务管理的核心是调度。

要理解调度，就需要先了解 CPU 的结构和功能。

## CPU调度的核心

### 寄存器

以 ARM 架构 MCU 中的基本寄存器来举例，以下的寄存器是最基本的几个寄存器，先来认识一下他们

```text
xPSR
R15(PC)
R14(LR)
R12
R3
R2
R1
R0
```

先举个例子，以下是一个非常简单的 C 语言程序，结合这个例子来理解寄存器的作用

```c
int main(int argc, char** argv){
    return 0;
}
```

1. 在上面 C 程序的例子中， `R0`中存放的是 `argc`的值，`R1`存放的是 `argv`的值，如果一个程序有4个参数，分别可以使用 `R0 - R3`，超过 4 个参数，一般就要用到栈了，这个后面再解释
2. 当程序返回的时候，它的值也是存放在 `R0`中
3. `R12`用来作为程序执行过程中交换数据的寄存器
4. `R14(LR)`是用来存放程序返回后应该执行的后续程序的地址，程序执行过程中可以借用这个寄存器，但是返回的时候，一定要恢复
5. `R15(PC)`是用来告诉CPU现在执行到哪里了，这个寄存器不能用做它用！
6. `xPSR`是 ARM 中特殊的寄存器，值一般都是`0x01000000`，这个`1`标识在`Thumb`模式下执行，这里不做过多的讨论，理解`Thumb`模式是`ARM`提供的一种高效压缩代码容量的执行方式。
7. 除了上面列举的基本寄存器以外，MCU还提供了其他的寄存器，如`R4 - R11`，这些寄存器为程序运行提供了便利，程序在运行过程中可以充分利用这些寄存器来存储中间数据，大大提高运行效率。
8. 程序执行的过程，就是通过将参数放入到对应的寄存器中，然后改变`PC`寄存器的值，让CPU执行`PC`指定位置的程序，并在 执行之前，将返回的地址保存在`LR`里，这样，当程序执行完成后，就通过`LR`返回到之前的位置(TODO: 这里可以用图片或者动画来展示)

总结：

通过上面的介绍：

1. 了解了MCU提供的寄存器以及他们的基本用途；
2. 了解了寄存器是怎么被程序使用的，程序的参数和寄存器的关系，程序返回的值与寄存器的关系
3. 认识了用做特殊用途的寄存器，比如`LR`, `PC`,`xPSR`等

### 栈

寄存器的数量非常有限，而程序运行过程中需要保存大量的状态数据，寄存器就会出现不够用的情况，这个时候，就需要用到栈；

当程序出现函数调用的时候，就需要将调用前的寄存器的值保存下来，当被调用的函数执行完成后，就要恢复这些寄存器的值，让之前的程序继续运行，保存寄存器的值就需要用到栈；

**自动栈管理**

CPU会对基本寄存器进行自动入栈和出栈管理，当调用函数之前，会将基本寄存器的值自动压入当前任务的栈中；当返回的时候，再从被返回的任务栈中自动回复基本寄存器的值！



**手动入栈**

除了基本寄存器以外，还有`R4-R11`等其他的寄存器，这些寄存器CPU不会自动管理，需要我们手动管理，但是程序一般是通过C语言编写，并编译为机器代码的，作为程序的开发者，其实我们也不知道到底一个函数用到了哪些寄存器，因此，最保险的办法，就是将其他的寄存器都保存下来，等返回的时候，再从栈里面回复这些寄存器的值！



总结：

通过上面的介绍，了解了：

1. 程序运行时通过栈来保存更对的信息
2. 出现函数调用时，会将寄存器的值保存在栈当中，这里的栈是让出运行时间的程序的栈！
3. 当函数返回时，会从栈中恢复寄存器的值
4. 基本寄存器是有CPU自动管理的
5. 除了基本寄存器，其他的寄存器需要手动管理